## Verwendung als Programmierer (Erweiterung des bestehenden Frameworks)

Schwerpunkt bei der Entwicklung des Programms lag darauf die Anwendung möglich offen zu gestallten und es fremden Programmierern möglichst einfach zu gestallten eigene Element-Definitionen hinzuzufügen.

Um neue Element-Definitionen zum Programm hinzuzufügen reicht es aus entsprechend kompatible kompilierte *class*-Dateien in eines der folgenden Verzeichnisse abzulegen:

- Im Programm-Verzeichniss im Paket `reflection.nodedefinitions`. (Hierbei ist auf die korrekte Paketbezeichnung `package reflection.nodedefinitions` zu achten)
- Innerhalb des Projekt-Verzeichnisses im Unterverzeichniss `nodedefinitions`.

### Umsetzung von Element-Definitionen

Eine Klasse ist eine kompatible Element-Definition wenn diese von der Klasse `reflection.common.NodeDefinition` ableitet.

Um Kompilier-Fehler zu vermeiden ist es empfehlenswert das Paket [`reflection.common`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/common) innerhalb der Entwicklungsumgebung im Klassenpfad liegen zu haben (hierfür reicht es einfach dieses Paket in das aktuelle Quellverzeichniss zu kopieren, hierbei darauf achten dass die Ordnerstruktur des Paketes `./reflection/common/` bewahrt bleibt).

Zur Unterstützung ist es darüberhinaus zusätzlich förderlich die Pakete [`reflection.customdatatypes`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/customdatatypes) sowie [`reflection.additionalnodedefinitioninterfaces`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/additionalnodedefinitioninterfaces) auch über den Klassenpfad verfügbar zu haben. Das Paket `reflection.customdatatypes` stellt Datentypen zur Verfügung welche zusätzlich zu den bereits gängigen Java-Datentypen über Eingänge entgegen genommen werden sowie über Ausgänge weiter gereicht werden können. Das Paket `reflection.additionalnodedefinitioninterfaces` stellt Schnittstellen zur Verfügung welche es erlauben Element-Definition um zusätzliche Funktionalitäten zu erweitern welche nicht bereits von `reflection.NodeDefinition` abgedeckt werden.

Es gibt fünf wichtigste Schnittstellen im Bezug auf Element-Definition. Diese sind: `NodeDefinition`, `ContextCreator`, `InOut`, `ContextCreatorInOut`, sowie `API`, aus dem Paket `reflection.common`. Im folgenden werde ich einzelnen auf die Verwendung dieser Schnittstellen eingehen.

Am offensichtlich wichtigsten ist die Schnittstelle `NodeDefinition`. Diese Schnittstellen muss von jeder Element-Definition implementiert werden. Folgende Methoden werden von `NodeDefinition` verlangt:

- `public int getInletCount()`: Muss die Anzahl der Eingänge zurück geben. virtuelle Eingänge werden nicht mitgezählt.
- `public Class getClassForInlet(int inletIndex)`: Muss die Datentypen für die Eingänge `0` bis `getInletCount()-1` zurück geben.
- `public String getNameForInlet(int inletIndex)`: Muss den Namen für die Eingänge `0` bis `getInletCount()-1` zurück geben. 
- `boolean isInletForArray(int inletIndex)`: Muss zurück geben ob die Eingänge `0` bis `getInletCount()-1` eine Liste als Eingabe erwarten. 
- `public boolean isInletEngaged(int inletIndex)`: Muss zurück geben ob die Eingänge `0` bis `getInletCount()-1` verpflichtend verbunden sein müssen oder ob auf Standardwert zurück gegriffen werden kann. 
- `public int getOutletCount()`: Muss die Anzahl der Ausgänge zurück geben. virtuelle Ausgänge werden nicht mitgezählt.
- `public Class getClassForOutlet(int outletIndex)`: Muss die Datentypen für die Ausgänge `0` bis `getOutletCount()-1` zurück geben.
- `public String getNameForOutlet(int outletIndex)`: Muss den Namen für die Ausgänge `0` bis `getOutletCount()-1` zurück geben. 
- `public boolean isOutletForArray(int outletIndex)`: Muss zurück geben ob die Ausgänge `0` bis `getOutletCount()-1` eine Liste als Ausgabe geben werden. 
- `public String getName()`: Muss den Namen des Elementes zurück geben.
- `public String getDescription()`: Muss die Beschreibung des Elementes zurück geben. Text welcher nach `//tags//` angegeben ist wird abgeschnitten und dient nur dabei Elemente besser zu finden. Tags welche zwischen `[` und `]` angegeben werden werden als Kategorie interpretiert.
- `public String getUniqueName()`: Muss einen eindeutigen Bezeichner dieser Element-Definition zurück geben.
- `public String getIconName()`: Soll `null` oder den Namen der Datei angeben welche als Icon des Elementes verwendet werden soll
- `public int getVersion()`:  Muss die Versionsnummer der Element-Definitionen zurück geben.
- `public void run(InOut io, API api) throws Exception`: Dies ist die Methode in der die eigentliche Arbeit durchgeführt werden soll.

Wie im Abschnitt Funktionsweise gesehen gibt es zusätzlich zu *Einfachen Elementen* auch *Kontext Erzeugende Elemente*. Um solche zu Kennzeichnen existiert die zusätzliche Schnittstelle `ContextCreator`. `ContextCreator` leitet von `NodeDefinition` ab und erwartet somit von der implementierenden Klasse alle Methoden dieser zu unterstützen. Die Schnittstelle `ContextCreator` führt jedoch selbst **keine** neuen Methoden ein. Die Schnittstelle dient alleinig dazu *Kontext Erzeugende Element-Definitionen* zu kennzeichnen und nicht dazu diese um eine Funktionalität zu erweitern.

Bei der Entwicklung von neuen Element-Definitionen sind zusätzlich ist die Schnittstellen `InOut`, `ContextCreatorInOut` sowie `API` relevant. Bevor ich auf diese eingehe muss angemerkt werden wieso es sich bei diesen um Schnittstellen und nicht um Klassen handelt. Der Grund hierfür liegt nicht in einer technischen Notwendigkeit sondern daran wie das Paket `reflection.common` verwendet werden können soll. Sinn dieses Paketes ist dass dieses (mit den in ihr befindlichen Klassen und Schnittstellen) in einen beliebigen Klassenpfad kopiert werden kann und damit als Schnittstelle zwischen meinem Programm und den von anderen Entwicklern erstellten Klassen fungieren kann. Würden sich Klassen welche in Abhängigkeit mit andern Klassen meines Programms stehen innerhalb von diesem Paket befinden so würde dieses einfache Kopieren unweigerlich zu Kompilierfehlern führen welche nur sehr schwer vermieden werden könnten. Um dieses Problem zu umgehen habe ich von Klassen welche extern benötigt werden obwohl diese interne Abhängigkeiten besitzen jeweils nur eine Schnittstelle in das Paket `reflection.common` gelegt. Auf diese Weise stelle ich sicher dass Objekte dieser Klassen extern verwendet werden können ohne dass ihre genaue Implementierung extern vorhanden sein muss.

`InOut`-Objekte dienen dazu Daten an Eingängen abzurufen und Daten an Ausgänge weiter zu geben. Hierfür stehen unter anderem folgende Methoden zur Verfügung:

- `public Object[] in(int i, Object[] def) throws TerminatedException`: Ruft Daten an Eingang *i* ab. Falls *i* nicht verbunden wird *def* zurückgegeben.
- `public Object in0(int i, Object def) throws TerminatedException`: Ruft Liste von Daten an Eingang *i* ab. Falls *i* nicht verbunden wird *def* zurückgegeben.
- `public void out(int i, Object ausgabe) throws TerminatedException`:  Gibt Daten an Ausgang *i* weiter.
- `public void out(int i, Object[] ausgabe) throws TerminatedException`: Gibt Liste von Daten an Ausgang *i* weiter.
- `public boolean outConnected(int i) throws TerminatedException`: Gibt an ob Ausgang *i* verbunden ist.
- `public long getContextIdentifier() throws TerminatedException`: Gibt die Identifikation des aktuellen Kontextes zurück.

`ContextCreatorInOut` ist eine Erweiterung von `InOut`. Wenn es sich bei einer Element-Definitionen um eine *Kontexte Erzeugende Element-Definitionen* (diese also von`ContextCreator` ableitet), erhält die `run`-Methode als `io` Parameter ein Objekt welches `ContextCreatorInOut` implementiert. Dieses kann dementsprechend von `InOut` nach `ContextCreatorInOut` gecastet werden und erweitert dieses un folgende Methoden:

- `public void startNewContext() throws Exception, TerminatedException`: Startet einen neuen Kontext mit den den Ausgangs-Daten welche zu diesem Zeitpunkt bereits weiter gegeben wurden.
- `public int getRunningContextCount() throws TerminatedException`: Gibt zurück wieviele Kind-Kontexte bereits laufen. (Bevor `startNewContext()` das erste mal aufgerufen wurde dementsprechend 0)

`API`-Objekte dienen dazu eine Reihe von Funktionalitäten der `run`-Methode zur Verfügung zu stellen. Die angebotenen Funktionalitäten würden sich grösstenteils auch selbst implementieren lassen, jedoch sollen diese die Entwicklung von Element-Definitionen unterstützen und wiederholenden Programmcode verhindern.

#### Beispiel: Primzahl-Test

````java
import reflection.common.*;

public class PrimTestNodeDefinition implements NodeDefinition {

    public int getInletCount()                 { return 1; }

    public Class getClassForInlet(int index)   { return Long.class; }

    public String getNameForInlet(int index)   { return "n"; }

    public boolean isInletEngaged(int i)       { return true; }

    public boolean isInletForArray(int index)  { return false; }

    public int getOutletCount()                { return 1; }

    public Class getClassForOutlet(int index)  { return Boolean.class; }

    public String getNameForOutlet(int index)  { return "Ist Primzahl"; }

    public boolean isOutletForArray(int index) { return false; }

    public String getName()                    { return "Primzahl-Test"; }

    public String getDescription() {
        return "Testet ob es sich bei einer Zahl n um eine Primzahl handelt."
        + Dies kann bei grossen Zahlen eine längere Zeit in Anspruch nehmen."
        + TAG_PREAMBLE + " [Math] Prim Primzahl Test Probieren ";
    }

    public String getUniqueName() { return "buildin.PrimTest"; }

    public String getIconName() { return "Is-Prim_30px.png"; }

    public int getVersion() { return 1; }

    public void run(InOut io, API api) {
        Long n = io.inN(0, 1).longValue();
        io.out(0, isPrim(n, io, api));
    }

    public static boolean isPrim(long n, InOut io, API api) { // Hilfsmethode
        if (n == 1)
            return false;
        if (n < 0) {
            api.additionalPrintErr("Primzahlen sind immer positiv");
            return false;
        }
        if (n <= 2)
            return true;
        for (long i = 2; i <= n / 2; i++) {
            if (n % i == 0)
                return false;
            if (i % 1000 == 0)
                io.terminatedTest();
        }
        return true;
    }

}
````

#### TerminatedException

Viele Methoden der Schnittstellen `InOut`, `ContextCreatorInOut` und `API` sind mit `throws TerminatedException` gekennzeichnet. Der Grund hierfür ist dass auf diese Art laufende `run`-Methode abgebrochen werden können im Fall dass die Ausführung vorzeitig beendet wurde. Um zu verhindern dass in Situationen in welchen keine Framework-Methoden verwendet werden die Ausführung nicht abgebrochen werden kann soll aus diesem Grund wie im Beispiel gezeigt von Zeit zu Zeit manuell die Methode `io.terminatedTest()` aufgerufen werden.

#### Datentypen

Um Element-Definitionen konsistent zu halten ist es zu empfehlen in der Regel folgende Klassen (bzw. Schnittstellen) als Datentypen zu verwenden:

- `java.lang.Boolean`
- `java.lang.String`
- `java.lang.Character`
- `java.lang.Number` (Schnittstelle; Implementierung: `Byte`, `Short`, `Integer`, `Long`, `Float` und `Double`)
- `java.lang.Byte`
- `java.lang.Short`
- `java.lang.Integer`
- `java.lang.Long`
- `java.lang.Float`
- `java.lang.Double`
- `java.util.Date`
- `java.awt.Color`
- `java.lang.Object`
- `java.​awt.Image` (Abstrakte Klasse; Ableitung: `java.​awt.BufferedImage`)
- `java.​ni.​File`
- `reflection.customdatatypes.BooleanGrid`
- `reflection.customdatatypes.math.MathObject` (Abstrakte Klasse; Ableitungen: `NumberMathObject`, `Matrix` und `Vector`)
- `reflection.customdatatypes.math.Matrix` (Abstrakte Klasse; Ableitungen: `OneDimensionalArrayBasedMatrix`, `PrimitiveDoubleWrappingMatrix`, `PrimitiveFloatWrappingMatrix` und `TwoDimensionalArrayBasedMatrix`)
- `reflection.customdatatypes.math.Vector` (Schnittstelle; Implementierung: `ArrayBasedVector`)
- `reflection.customdatatypes.SourceCode`
- `reflection.​customdatatypes.Function` (Abstrakte Klasse, muss selbst implementiert werden)
- `reflection.​customdatatypes.​rawdata.RawData` (bzw. deren Erweiterungen `RawDataFromFile` und `RawDataFromNetwork`)
- `reflection.customdatatypes.camera.​Camera` (Schnittstelle; Implementierung: `Webcam`)
- `reflection.customdatatypes.SmartIdentifier`