## Verwendung als Programmierer (Erweiterung des bestehenden Frameworks)

Schwerpunkt bei der Entwicklung des Programms lag darauf die Anwendung möglich offen zu gestallten und es fremden Programmierern möglichst einfach zu gestallten eigene Element-Definitionen hinzuzufügen.

Um neue Element-Definitionen zum Programm hinzuzufügen reicht es aus entsprechend kompatible kompilierte *class*-Dateien in eines der folgenden Verzeichnisse abzulegen:

- Im Programm-Verzeichniss im Paket `reflection.nodedefinitions`. (Hierbei ist auf die korrekte Paketbezeichnung `package reflection.nodedefinitions` zu achten)
- Innerhalb des Projekt-Verzeichnisses im Unterverzeichniss `nodedefinitions`.

### Umsetzung von Element-Definitionen

Eine Klasse ist eine kompatible Element-Definition wenn diese von der Klasse `reflection.common.NodeDefinition` ableitet.

Um Kompilier-Fehler zu vermeiden ist es empfehlenswert das Paket [`reflection.common`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/common) innerhalb der Entwicklungsumgebung im Klassenpfad liegen zu haben (hierfür reicht es einfach dieses Paket in das aktuelle Quellverzeichniss zu kopieren, hierbei darauf achten dass die Ordnerstruktur des Paketes `./reflection/common/` bewahrt bleibt).

Zur Unterstützung ist es darüberhinaus zusätzlich förderlich die Pakete [`reflection.customdatatypes`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/customdatatypes) sowie [`reflection.additionalnodedefinitioninterfaces`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/additionalnodedefinitioninterfaces) auch über den Klassenpfad verfügbar zu haben. Das Paket `reflection.customdatatypes` stellt Datentypen zur Verfügung welche zusätzlich zu den bereits gängigen Java-Datentypen über Eingänge entgegen genommen werden sowie über Ausgänge weiter gereicht werden können. Das Paket `reflection.additionalnodedefinitioninterfaces` stellt Schnittstellen zur Verfügung welche es erlauben Element-Definition um zusätzliche Funktionalitäten zu erweitern welche nicht bereits von `reflection.NodeDefinition` abgedeckt werden.

Es gibt fünf wichtigste Schnittstellen im Bezug auf Element-Definition. Diese sind: `NodeDefinition`, `ContextCreator`, `InOut`, `ContextCreatorInOut`, sowie `API`, aus dem Paket `reflection.common`. Im folgenden werde ich einzelnen auf die Verwendung dieser Schnittstellen eingehen.

Am offensichtlich wichtigsten ist die Schnittstelle `NodeDefinition`. Diese Schnittstellen muss von jeder Element-Definition implementiert werden. Folgende Methoden werden von `NodeDefinition` verlangt:

- `public int getInletCount()`: Muss die Anzahl der Eingänge zurück geben. virtuelle Eingänge werden nicht mitgezählt.
- `public Class getClassForInlet(int inletIndex)`: Muss die Klasse für die Eingänge `0` bis `getInletCount()-1` zurück geben.
- `public String getNameForInlet(int inletIndex)`: Muss den Namen für die Eingänge `0` bis `getInletCount()-1` zurück geben. 
- `boolean isInletForArray(int inletIndex)`: Muss zurück geben ob die Eingänge `0` bis `getInletCount()-1` eine Liste als Eingabe erwarten. 
- `public boolean isInletEngaged(int inletIndex)`: Muss zurück geben ob die Eingänge `0` bis `getInletCount()-1` verpflichtend verbunden sein müssen oder ob auf Standardwert zurück gegriffen werden kann. 
- `public int getOutletCount()`: Muss die Anzahl der Ausgänge zurück geben. virtuelle Ausgänge werden nicht mitgezählt.
- `public Class getClassForOutlet(int outletIndex)`: Muss die Klasse für die Ausgänge `0` bis `getOutletCount()-1` zurück geben.
- `public String getNameForOutlet(int outletIndex)`: Muss den Namen für die Ausgänge `0` bis `getOutletCount()-1` zurück geben. 
- `public boolean isOutletForArray(int outletIndex)`: Muss zurück geben ob die Ausgänge `0` bis `getOutletCount()-1` eine Liste als Ausgabe geben werden. 
- `public String getName()`: Muss den Namen des Elementes zurück geben.
- `public String getDescription()`: Muss die Beschreibung des Elementes zurück geben. Text welcher nach `//tags//` angegeben ist wird abgeschnitten und dient nur dabei Elemente besser zu finden. Tags welche zwischen `[` und `]` angegeben werden werden als Kategorie interpretiert.
- `public String getUniqueName()`: Muss einen eindeutigen Bezeichner dieser Element-Definition zurück geben.
- `public String getIconName()`: Soll `null` oder den Namen der Datei angeben welche als Icon des Elementes verwendet werden soll
- `public int getVersion()`:  Muss die Versionsnummer der Element-Definitionen zurück geben.
- `public void run(InOut io, API api) throws Exception`: Dies ist die Methode in der die eigentliche Arbeit durchgeführt werden soll.

Wie im Abschnitt Funktionsweise gesehen gibt es zusätzlich zu *Einfachen Elementen* auch *Kontext Erzeugende Elemente*. Um solche zu Kennzeichnen existiert die zusätzliche Schnittstelle `ContextCreator`. `ContextCreator` leitet von `NodeDefinition` ab und erwartet somit von der implementierenden Klasse alle Methoden dieser zu unterstützen. Die Schnittstelle `ContextCreator` führt jedoch selbst **keine** neuen Methoden ein. Die Schnittstelle dient alleinig dazu *Kontext Erzeugende Element-Definitionen* zu kennzeichnen und nicht dazu diese um eine Funktionalität zu erweitern.

Bei der Entwicklung von neuen Element-Definitionen sind zusätzlich ist die Schnittstellen `InOut`, `ContextCreatorInOut` sowie `API` relevant. Bevor ich auf diese eingehe muss angemerkt werden wieso es sich bei diesen um Schnittstellen und nicht um Klassen handelt. Der Grund hierfür liegt nicht in einer technischen Notwendigkeit sondern daran wie das Paket `reflection.common` verwendet werden können soll. Sinn dieses Paketes ist dass dieses (mit den in ihr befindlichen Klassen und Schnittstellen) in einen beliebigen Klassenpfad kopiert werden kann und damit als Schnittstelle zwischen meinem Programm und den von anderen Entwicklern erstellten Klassen fungieren kann. Würden sich Klassen welche in Abhängigkeit mit andern Klassen meines Programms stehen innerhalb von diesem Paket befinden so würde dieses einfache Kopieren unweigerlich zu Kompilierfehlern führen welche nur sehr schwer vermieden werden könnten. Um dieses Problem zu umgehen habe ich von Klassen welche extern benötigt werden obwohl diese interne Abhängigkeiten besitzen jeweils nur eine Schnittstelle in das Paket `reflection.common` gelegt. Auf diese Weise stelle ich sicher dass Objekte dieser Klassen extern verwendet werden können ohne dass ihre genaue Implementierung extern vorhanden sein muss.

`InOut`-Objekte dienen dazu Daten an Eingängen abzurufen und Daten an Ausgänge weiter zu geben. Hierfür stehen unter anderem folgende Methoden zur Verfügung:

- `public Object[] in(int i, Object[] def) throws TerminatedException`: Ruft Daten an Eingang *i* ab. Falls *i* nicht verbunden wird *def* zurückgegeben.
- `public Object in0(int i, Object def) throws TerminatedException`: Ruft Liste von Daten an Eingang *i* ab. Falls *i* nicht verbunden wird *def* zurückgegeben.
- `public void out(int i, Object ausgabe) throws TerminatedException`:  Gibt Daten an Ausgang *i* weiter.
- `public void out(int i, Object[] ausgabe) throws TerminatedException`: Gibt Liste von Daten an Ausgang *i* weiter.
- `public boolean outConnected(int i) throws TerminatedException`: Gibt an ob Ausgang *i* verbunden ist.
- `public long getContextIdentifier() throws TerminatedException`: Gibt die Identifikation des aktuellen Kontextes zurück.

`ContextCreatorInOut` ist eine Erweiterung von `InOut`. Wenn es sich bei einer Element-Definitionen um eine *Kontexte Erzeugende Element-Definitionen* (diese also von`ContextCreator` ableitet), erhält die `run`-Methode als `io` Parameter ein Objekt welches `ContextCreatorInOut` implementiert. Dieses kann dementsprechend von `InOut` nach `ContextCreatorInOut` gecastet werden und erweitert dieses un folgende Methoden:

- `public void startNewContext() throws Exception, TerminatedException`: Startet einen neuen Kontext mit den den Ausgangs-Daten welche zu diesem Zeitpunkt bereits weiter gegeben wurden.
- `public int getRunningContextCount() throws TerminatedException`: Gibt zurück wieviele Kind-Kontexte bereits laufen. (Bevor `startNewContext()` das erste mal aufgerufen wurde dementsprechend 0)

`API`-Objekte dienen dazu eine Reihe von Funktionalitäten der `run`-Methode zur Verfügung zu stellen. Die angebotenen Funktionalitäten würden sich grösstenteils auch selbst implementieren lassen, jedoch sollen diese die Entwicklung von Element-Definitionen unterstützen und wiederholenden Programmcode verhindern.

#### Beispiel

````java
package reflection.nodedefinitions.math;

import reflection.common.API;
import reflection.common.InOut;
import reflection.common.NodeDefinition;

public class PrimTestNodeDefinition implements NodeDefinition {
    @Override
    public int getInletCount() { return 1; }

    @Override
    public Class getClassForInlet(int index) { return Long.class; }

    @Override
    public String getNameForInlet(int index) { return "n"; }

    @Override
    public boolean isInletEngaged(int i) { return true; }

    @Override
    public boolean isInletForArray(int index) { return false; }

    @Override
    public int getOutletCount() { return 1; }

    @Override
    public Class getClassForOutlet(int index) { return Boolean.class; }

    @Override
    public String getNameForOutlet(int index) { return "Ist Primzahl"; }

    @Override
    public boolean isOutletForArray(int index) { return false; }

    @Override
    public String getName() {
        return "Primzahl-Test";
    }

    @Override
    public String getDescription() {
        return "Testet ob es sich bei einer Zahl n um eine Primzahl handelt. Dies kann bei grossen Zahlen eine längere Zeit in Anspruch nehmen." + TAG_PREAMBLE + " [Math] Prim Primzahl Test Probieren ";
    }

    @Override
    public String getUniqueName() {
        return "buildin.PrimTest";
    }

    @Override
    public String getIconName() {
        return "Is-Prim_30px.png";
    }

    @Override
    public int getVersion() {
        return 1;
    }

    @Override
    public void run(InOut io, API api) {

        Long n = io.inN(0, 1).longValue();

        io.out(0, isPrim(n, io));
    }

    public static boolean isPrim(long n, InOut io) {
        if (n == 1) {
            return false;
        }
        if (n < 0) {
            System.err.println("Primzahlen sind immer positiv");
            return false;
        }
        if (n <= 2) {
            return true;
        }
        for (long i = 2; i <= n / 2; i++) {
            if (n % i == 0) {
                return false;
            }
            if (i % 1000 == 0) {
                io.terminatedTest();
            }
        }
        return true;
    }

}
````




TerminatedException







.

.

.

.

.

.



SmartIdentifier