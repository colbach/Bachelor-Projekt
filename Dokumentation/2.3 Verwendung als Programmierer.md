## Verwendung als Programmierer (Erweiterung des bestehenden Frameworks)

Schwerpunkt bei der Entwicklung des Programms lag darauf die Anwendung möglich offen zu gestallten und es fremden Programmierern möglichst einfach zu gestallten eigene Element-Definitionen hinzuzufügen.

Um neue Element-Definitionen zum Programm hinzuzufügen reicht es aus entsprechend kompatible kompilierte *class*-Dateien in eines der folgenden Verzeichnisse abzulegen:

- Im Programm-Verzeichniss im Paket `reflection.nodedefinitions`. (Hierbei ist auf die korrekte Paketbezeichnung `package reflection.nodedefinitions` zu achten)
- Innerhalb des Projekt-Verzeichnisses im Unterverzeichniss `nodedefinitions`.

### Umsetzung von Element-Definitionen

Eine Klasse ist eine kompatible Element-Definition wenn diese von der Klasse `reflection.common.NodeDefinition` ableitet.

Um Kompilier-Fehler zu vermeiden ist es empfehlenswert das Paket [`reflection.common`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/common) innerhalb der Entwicklungsumgebung im Klassenpfad liegen zu haben (hierfür reicht es einfach dieses Paket in das aktuelle Quellverzeichniss zu kopieren, hierbei darauf achten dass die Ordnerstruktur des Paketes `./reflection/common/` bewahrt bleibt).

Zur Unterstützung ist es darüberhinaus zusätzlich förderlich die Pakete [`reflection.customdatatypes`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/customdatatypes) sowie [`reflection.additionalnodedefinitioninterfaces`](https://github.com/colbach/Bachelor-Projekt/tree/master/Hauptprogramm/src/reflection/additionalnodedefinitioninterfaces) auch über den Klassenpfad verfügbar zu haben. Das Paket `reflection.customdatatypes` stellt Datentypen zur Verfügung welche zusätzlich zu den bereits gängigen Java-Datentypen über Eingänge entgegen genommen werden sowie über Ausgänge weiter gereicht werden können. Das Paket `reflection.additionalnodedefinitioninterfaces` stellt Interfaces zur Verfügung welche es erlauben Element-Definition um zusätzliche Funktionalitäten zu erweitern welche nicht bereits von `reflection.NodeDefinition` abgedeckt werden.

Die fünf wichtigsten Schnittstellen im Bezug auf Element-Definition sind: `NodeDefinition`, `ContextCreator`, `InOut`, `ContextCreatorInOut`, sowie `API`, aus dem Paket `reflection.common`. Im folgenden werde ich einzelnen auf die Verwendung dieser Schnittstellen eingehen.

Am offensichtlich wichtigsten ist die Schnittstelle `NodeDefinition`. Diese Schnittstellen muss von jeder Element-Definition implementiert werden. Folgende Methoden werden von `NodeDefinition` verlangt:

- `public int getInletCount()`: Muss die Anzahl der Eingänge zurück geben. virtuelle Eingänge werden nicht mitgezählt.
- `public Class getClassForInlet(int inletIndex)`: Muss die Klasse für die Eingänge `0` bis `getInletCount()-1` zurück geben.
- `public String getNameForInlet(int inletIndex)`: Muss den Namen für die Eingänge `0` bis `getInletCount()-1` zurück geben. 
- `boolean isInletForArray(int inletIndex)`: Muss zurück geben ob die Eingänge `0` bis `getInletCount()-1` eine Liste als Eingabe erwarten. 
- `public boolean isInletEngaged(int inletIndex)`: Muss zurück geben ob die Eingänge `0` bis `getInletCount()-1` verpflichtend verbunden sein müssen oder ob auf Standardwert zurück gegriffen werden kann. 
- `public int getOutletCount()`: Muss die Anzahl der Ausgänge zurück geben. virtuelle Ausgänge werden nicht mitgezählt.
- `public Class getClassForOutlet(int outletIndex)`:
- `public String getNameForOutlet(int outletIndex)`:
- `public boolean isOutletForArray(int outletIndex)`:
- `public static String TAG_PREAMBLE = "//tags//"`:
- `public String getName()`:
- `public String getDescription()`:
- `public String getUniqueName()`:
- `public String getIconName()`:
- `public int getVersion()`:
- `public void run(InOut io, API api) throws Exception`:



















SmartIdentifier