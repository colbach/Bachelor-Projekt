# Technische Umsetzung

## Implementierung

### Aufbau

Das Programm ist modular aufgebaut und besteht grundlegend aus folgenden Modulen (intern):

- Hauptmodul (Paket: `main.*`, Wichtigste Klassen: `MainClass`, `ComponentHub`)
- Hilfs-Klassen (Paket: `utils.*`)
- Model (Paket: `model.*`, Wichtigste Klassen: `Project`, `Node`)
- Projektausführung (Paket: `projectrunner.*`, Wichtigste Klassen:  `ProjectRunner`, `ProjectExecution`)
- Kommandozeile (Paket: `commandline.*`, Wichtigste Klasse: `CommandLine`)
- Grafische Benutzeroberfläche (Paket: `view.*`, Wichtigste Klasse: `MainWindow`)
- Persistente Einstellungen (Paket: `settings.*`, Wichtigste Klasse: `Settings`, `GeneralSettings`)
- Protokollierung (Paket: `logging.*`, Wichtigste Klassen: `AdvancedLogger`, `AdditionalLogger`)
- Über Reflexion geladene Klassen und geteilte Klassen/Schnittstellen (Paket: `reflection.*`, Wichtigste Klasse: `NodeDefinition`)

Der folgende Aufbau soll einen Überblick darüber verschaffen wie die Klassen der einzelnen Module zusammen arbeiten:

![](Grafiken/Technische-Umsetzung/Aufbau.pdf)

Im folgenden werde ich auf die einzelnen Module eingehen und beschreiben welche Tätigkeit diese erfüllen und wie diese funktionieren.

### Hauptmodul

#### MainClass

Das Hauptmodul hat die Aufgabe die Anwendung zu starten und alle nötigen Komponenten zu laden. Je nachdem ob Konsole, Grafischen Benutzerinterface oder Beides gestartet werden soll, werden die verschiedenen Module geladen.

#### ComponentHub

Die Klasse ComponentHub stellt das Drehkreuz über welches das grafische Benutzerinterface, die Kommandozeile und das Model kommunizieren.
Zugriff auf den ComponentHub erfolgt über ein Singleton und ist theoretisch aus dem gesamten Programm möglich. Der ComponentHub kann jeweils eine Instanz auf ein `Project`-Objekt, ein `CommandLinePrompt`-Objekt und ein `MainWindow`-Objekt halten. Ist die Kommandozeile oder das grafische Benutzerinterface nicht aktiv so bleibt dieses Attribut *null*.

### Hilfs-Klassen

Eine ganze Reihe nützliche Hilfsklassen sind in dem Paket `utils.*` zusammengefasst. Die hier befindlichen Hilfs-Methoden, Hilfs-Strukturen werden durchgängig durch das Programm an den verschiedensten Stellen verwendet und sollen den restlichen Code übersichtlicher und lesbarer machen sowie Redundanz und die damit verbundene Fehleranfälligkeit vermeiden.

### Model

Das Model ist grundlegend wie folgt aufgebaut:

![](Grafiken/Technische-Umsetzung/Aufbau-Model.pdf)

Klasse | Enthält (gekürzt) | Beschreibung
:-- | :-- | :--
`Project` | Elemente (Liste von `Node`-Objekten), Verweise auf projektspezifische Verzeichnisse und Dateien, Projekteinstellungen (`ProjectSettings`) | Repräsentiert ein bestimmtes vom Benutzer erstelltes Projekt.
`Node`| Eingänge (Liste von `Inlet`-Objekten), Ausgänge (Liste von `Outlet`-Objekten), Position (X- und Y-Koordinate), Identifikation (`long`), Zugehörige Element-Definition (`NodeDefinition`) | Repräsentiert ein in einem Projekt platziertes Element.
`Inlet` | Verbundene Ausgänge (Liste von `Outlet`-Objekten), Identifikation (`long`), Zugehöriges Element (`Node`), Index (`int`) | Repräsentiert ein zu einem Element zugehörigen Eingang.
`Outlet` | Verbundene Eingänge (Liste von `Inlet`-Objekten), Identifikation (`long`), Zugehöriges Element (`Node`), Index (`int`) | Repräsentiert ein zu einem Element zugehörigen Eingang.

Zu beachten ist dass die Klasse `Node` selbst keine Informationen über Namen, Icons oder Typen der Ein und Ausgänge enthält. Informationen über diese sind nicht im Model sondern in den über Reflexion geladenen Element-Definitionen (`NodeDefinition`) enthalten.

#### Serialisierung und Deserialisierung von Projekten

Um Projekte persistent zu speichern müssen diese serialisiert werden. Dies könnte theoretisch mittels der Java-eigenen Standardimplementierung für die Serialisierung von Objekten realisiert werden jedoch wäre dies aus zwei Gründen problematisch. Zum einen könnte dies zu Inkompatibilität zwischen verschiedenen Programmversionen führen ausserdem würde dies es erschweren Projekt-Dateien händisch zu lesen oder zu bearbeiten. Um die bestmögliche Kontrolle über die Projektdateien zu haben, habe ich mich dazu entschieden die Serialisierung und Deserialisierung der Projektdateien selbst zu übernehmen.

Um eine transparente und stabile Projekt-Serialisierung zu garantieren habe ich mich dazu entschieden Projekte strukturiert in das JSON-Format umzuwandeln und dann als UTF-8 String zu serialisieren. Die JSON Struktur besteht auf der obersten Ebene aus drei Arrays. Das Array `"nodes"` enthält alle Elemente des Projektes, das Array `"inlets"` alle Eingänge und das Array `"outlets"` alle Ausgänge. Hierbei ist es nicht entscheidend ob die Ein-/Ausgänge verbunden oder nicht verbunden sind. Da Ein-/Ausgänge keine Angaben über ihren Index enthalten ist es zwingend nötig dass alle Ein-/Ausgänge in der Struktur enthalten sind da sich dieser sonst nicht wiederherstellen lassen würde. Innerhalb der JSON-Struktur werden alle Objekte mittels ihrem `ID`-Feld identifiziert. Diese Identifikationen entsprechen der des Models und bleiben über den gesamten Lebenszyklus des Projektes konsistent. Über ein Feld namens `definitionUniqueNameVersion` wird jedem Element eine Element-Definition zugeordnet welche beim Deserialisieren über reflexion geladen werden muss. Das Feld `settabledata` enthält vom Benutzer gesetzte *direkte Eingaben*.

Wie die JSON-Struktur soll anhand dem folgenden Beispiel demonstriert werden.

Dies ist ein einfacher "Hello World"-Aufbau aus dem ersten Beispiel des Abschnittes 2.2.2:

![](Grafiken/Technische-Umsetzung/Serialisierung-Hallo-Welt.pdf)

Nach der Umwandelung als JSON-Struktur sieht der Aufbau wie folgt aus:

```json
{
  "nodes" : [ {
    "id" : 209,
    "inlets" : [ ],
    "outlets" : [ 1153 ],
    "definitionUniqueNameVersion" : "special.directinput(java.lang.String)[0]",
    "uiCenterX" : -2147483648,
    "uiCenterY" : -2147483648,
    "settabledata" : [ "rO0ABXQACkhhbGxvIFdlbHQ=" ]
  }, {
    "id" : 207,
    "inlets" : [ ],
    "outlets" : [ 1146 ],
    "definitionUniqueNameVersion" : "buildin.Start1x[1]",
    "uiCenterX" : 156,
    "uiCenterY" : 217,
    "settabledata" : null
  }, {
    "id" : 208,
    "inlets" : [ 1147, 1148, 1149, 1150, 1151 ],
    "outlets" : [ 1152 ],
    "definitionUniqueNameVersion" : "buildin.PrintLog[1]",
    "uiCenterX" : 393,
    "uiCenterY" : 146,
    "settabledata" : null
  } ],
  "inlets" : [
     { "id" : 1147, "connectedOutlets" : [ 1153 ] },
     { "id" : 1148, "connectedOutlets" : [ ]      },
     { "id" : 1149, "connectedOutlets" : [ ]      },
     { "id" : 1150, "connectedOutlets" : [ ]      },
     { "id" : 1151, "connectedOutlets" : [ 1146 ] }
  ],
  "outlets" : [
     { "id" : 1153, "connectedInlets" : [ 1147 ] },
     { "id" : 1146, "connectedInlets" : [ 1151 ] },
     { "id" : 1152, "connectedInlets" : [ ]      }
  ]
}

```

Auffallend bei diesem Beispiel ist dass anstelle von "Hallo Welt" im Feld `settabledata` des Elementes mit der ID 208 `rO0ABXQACkhhbGxvIFdlbHQ=`  zu lesen ist. Dies liegt daran dass *direkte Eingaben* über die Java-Standart-Serialisierung in ein `byte`-Array umgewandelt werden und dann als Base64-String in die JSON-Struktur eingepflegt werden.

#### Schreiben und Lesen von Projekten

Projekt-Dateien werden als Verzeichnis in einem vom Benutzer definierten Pfad angelegt und wieder geladen. Hierbei sieht die Verzeichnis-Struktur wie folgt aus:

*Projekt-Name*`/`<br>
&nbsp;&nbsp;&nbsp;↳ `nodedefinitions/` <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↳ `info.txt`<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↳ `...` *(Optional: projekteigene Element-Definitionen)* <br>
&nbsp;&nbsp;&nbsp;↳ `properties.txt` <br>
&nbsp;&nbsp;&nbsp;↳ `structure.json` *(Projekt-Struktur als JSON-Datei)* <br>
&nbsp;&nbsp;&nbsp;↳ `versions/` <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↳ `...` *(Vorhergehende Projektversionen)* <br>

Bei jedem Speichervorgang wird die jeweils vorhergehende Projekt-Version in das Verzeichnis *Projekt-Name*`/versions/` verschoben. Innerhalb dieses Verzeichnisses werden alte Projekte-Verzeichnisse wie folgt benannt: *Versionsnummer* (*dd-MM-yyyy hh-mm-ss*).

Die Datei `properties.txt` dient dazu projektspezifische Parameter und Einstellungen zu speichern. Wie diese Datei genau aufgebaut ist wird im Abschnitt *Persistente Einstellungen* genauer erläutert.

### Projektausführung

#### Grundaufbau

Die Klassen welche für die Ausführung von Projekten zuständig sind sind grundlegend wie folgt miteinander verbunden:

![](Grafiken/Technische-Umsetzung/Aufbau-Projektausführung.pdf)

Hierbei ist anzumerken dass es sich nur um eine vereinfachte unvollständige Darstellung handelt welche nur die wichtigsten Klasse beinhaltet. Insgesamt ist für die Ausführung ein Konstrukt von 60 Klassen und Schnittstellen zuständig. Insbesondere sind folgende Elemente in der Darstellung nicht berücksichtigt: Herumgereichte Callback-Referenzen, Kontroll- und Steuerelemente sowie Debugger.

In der folgenden Liste gehe ich auf die wichtigsten Klassen die für die Projektausführung zuständig sind ein und erkläre deren Funktionen:

- `ProjektRunner`: Diese Klasse ist in der Hierarchie die oberste Klasse. Über das Singleton-Pattern wird sicher gestellt dass es nur genau eine Instanz dieser Klasse geben kann. über die Methode `executeProject(...)` kann die Ausführung von Projekten gestartet werden. Als Parameter erwartet die Methode unter anderem eine Reihe von Callback-Objekten welche während der Ausführung bei bestimmten Ereignissen oder bei Beendigung aufgerufen werden ausserdem gibt die Methode ein Objekt der Klasse `ProjectExecutionRemote` zurück. Falls bereits zu viele Projektausführung laufen wird eine `ToManyConcurrentProjectExecutions`-Exception geworfen (In der aktuellen Version ist die maximale Anzahl 1).
- `ProjectExecutionRemote` (Nicht in Darstellung): Dient zur Steuerung einer Projektausführung. Diese Objekte dieser Klasse zusammen mit Objekten der Klasse `DebuggerRemote` (nur bei aktivem Debugger) sind die einzigen Objekte der Projektausführung auf welche während der Ausführung von aussen zugegriffen werden kann.
- `ProjectExecution`: Diese Klasse repräsentiert eine Projektausführung. Im Konstruktor wird eine eindeutige Identifikation dieser Ausführung vergeben, der Debugger sowie eine Reihe von Kontroll- und Hilfsobjekten instanziiert. Ausserdem wird eine Instanz der Klasse `ExecutionHub` angelegt.
- `ExecutionHub`: Der ExecutionHub startet für jedes *Kontext Erzeugende Element* eine Instanz der Klasse `ExecutorCreatorContext` und sammelt diese Instanzen.
- `ExecutorContext`: Diese Klasse repräsentiert ein Kontext der Ausführung. Dieser besteht grundlegend aus einer Instanz der Klasse `ForEachCollectPoint` zur Sammlung der Daten aus *Für Alle*-Strukturen, einer Instanz der Klasse `ForEachAndReduceRelations` zur Ermittlung welche *Für Alle*-Elemente mit welchen *Sammeln*-Elementen verbunden sind sowie einer Instanz der Klasse `ExecutorRunEnvironment`. Ihre wichtigsten Methoden sind `submitExecutorIfNotSubmited` um Elemente anzustossen die noch nicht in `executorRunEnvironment` enthalten sind, `collect` um Daten von Eingängen zu sammeln (blockierend) sowie `deliver` um Daten von Ausgängen auszuliefern (und gegebenenfalls diese Elemente anzustossen).
- `ExecutorCreatorContext`: Diese Klasse erweitert die Klasse `ExecutorContext` und erweitert diese um die Funktionalität neue Kontexte zu erzeugen (also weitere Kind-Instanzen der Klasse `ExecutorContext`). Diese Funktionalität wird von der Klasse `ContextCreatorInOutImplementation` welche während der Laufzeit an *Kontext Erzeugende Elemente* übergeben wird.
- `executorRunEnvironment`: Dient zur Verwaltung der `ExecutorThread`-Objekte. Die wichtigste Methode ist die `submit`-Methode welche `Executor` annimmt und diesen einen `ExecutorThread` startet.
- `ExecutorThread`: Diese Klasse erbt von der Klasse `Thread` verpackt jeweils ein Objekt vom Typ `Executor` so dass dieser ausgeführt werden kann ohne dass der aufrufende Thread blockiert wird. 
- `Executor`: Diese Klasse ist abstrakt und wird von den Klassen `IfBackNodeExecutor` `IfForwardNodeExecutor`, `ForEachNodeExecutor`, `ReduceNodeExecutor`, `GeneralizedFirstValueNodeExecutor `, `ContextCreatingNodeExecutor` und `DefaultNodeExecutor` erweitert. Diese haben jeweils die Aufgabe ein Element auszuführen. Hierfür wird an dem entsprechenden Element (`Node`) die Element-Definition (`NodeDefinition`) abgefragt und von dieser die Methode `run` aufgerufen. Als Parameter wird jeweils ein Objekt der Klasse `InOutImplementation` und `APIImplementation` mitgegeben.
- `InOutImplementation` (Nicht in Darstellung): Dient dazu Daten für die Eingänge einen Elementes an Instanzen der Klasse `NodeDefinition` zu übergeben und Daten von Ausgängen von diesen zu sammeln.
- `APIImplementation` (Nicht in Darstellung): Stellt Framework-Funktionen Elementen Instanzen der Klasse `NodeDefinition` zur verfügung.
- `ContextCreatorInOutImplementation` (Nicht in Darstellung): Erweitert die Klasse `InOutImplementation` um die Methode `startNewContext()` um einen neuen Kontext zu erzeugen.

***??????? GENAUER ABLAUF Executor***

#### Debugger

Wenn beim Start der Projektausführung der zusätzliche Parameter `debug` auf `true` gesetzt wird eine Instanz der Klasse `Debugger` erzeugt und diese durch die gesamte Projektausführung weiter gereicht. Ist der Debugger nicht aktiv wird eine *null*-Referenz verwendet. Der Debugger stellt einen Logger zur Verfügung über welchen sämtliche kritische Ereignisse protokolliert werden. Ausserdem besitzt der Debugger Methoden welche bei jedem Zustandswechsel von Elementen aufgerufen werden. Diese Methoden haben im Normalfall keinen Effekt können jedoch im bestimmten Situationen blockieren.
Eine dieser Situationen kann beispielsweise eintreten wenn es sich bei dem Element welches gerade den Zustand wechselt um ein Element handelt welches als Breakpoint geführt wird (Diese werden von der Klasse `Breakpoints` verwaltet). Ist dieser Fall eingetreten werden sämtliche Elemente blockiert bis von aussen die Methode `releaseBlock()` aufgerufen wurde (Bzw. eine andere Methode welche diese intern aufruft). Da die Klasse `Debugger` eines der Klasse ist welche nur intern verwendet werden gibt es eine Klasse `DebuggerRemote` welche bestimmte Methode der Klasse `Debugger` nach aussen verfügbar macht.

### Kommandozeile

Das Modul für die Kommandozeile ist darauf ausgelegt einfach erweiterbar zu sein zu sein und hat mir während der Entwicklung geholfen mein Funktionen des Programms zu testen bevor die nötigen UI-Elemente dafür fertig waren. Insbesondere besteht die Kommandozeile aus 4 wichtigen Elementen auf welche ich im folgenden eingehe.

- `CommandLineThread`: Diese Klasse leitet von `Thread` und dient dazu dass die Kommandozeile ohne zu blockieren ausgeführt werden kann. 
- `CommandLinePrompt`: Kapselt das `CommandLine`-Objekt, interpretiert Benutzereingaben und gibt diese an das `CommandLine`-Objekt weiter.
- `CommandLine`: Die eigentliche Kommandozeile. Hier werden die Funktionen (Instanzen der Klasse `CommandLineFunction`) gesammelt und können ausgeführt werden.
- `CommandLineFunction` und dessen Implementierungen: Das Interface `CommandLineFunction` definiert welche Funktionen eine Kommandozeilen-Funktion besitzen muss damit diese von der Kommandozeile aufgerufen werden kann. Folgende Kommandozeilen-Funktionen sind in der aktuelllen Version vorhanden:  `AliasesCommandLineFunction`, `AnalyseProjectCommandLineFunction`, `CancelCommandLineFunction`, `CancelPromptCommandLineFunction`, `CountOnRunWindowsCommandLineFunction`, `DisposeOnRunWindowsCommandLineFunction`, `ExitCommandLineFunction`, `FileExistsCommandLineFunction`, `GetCommandLineFunction`, `HelpCommandLineFunction`, `PrintArgumentsCommandLineFunction`, `PWDCommandLineFunction`, `RedrawGUIProjectCommandLineFunction`, `RepairProjectCommandLineFunction`, `ResetGeneralSettingsCommandLineFunction`, `RunCommandLineFunction`, `SetCommandLineFunction`, `SetGetCommandLineFunction`, `SystemInformationCommandLineFunction`, `TestCommandLineFunction`

### Grafische Benutzeroberfläche



#### Fenster und Dialoge

Die folgende Übersicht stellt dar welche Fenster und Dialoge sich über das Hauptfenster erreichen lassen. Nicht in dieser Übersicht enthalten sind Fenster welche (1) Während der Projektausführung programmiertechnisch geöffnet werden können (2) Dialoge für *Direkte Eingänge* (3) Dialoge bei Fehlern oder Warnungen.

![](Grafiken/Technische-Umsetzung/Storyboard/Storyboard.pdf)

##### Fenster

Folgende Fenster wurden für das Programm implementiert und sind im Programmcode enthalten:

- Hauptfenster (`MainWindow`)
- Konsole / Log (`ConsoleWindow`): Zur Darstellung der Konsole oder Log.
- Debug Monitor (`DebugMonitorWindow`): Zur Darstellung von technischen Informationen zur aktuellen Projektausführung. (Hier sollen später auch noch andere Informationen wie Speicherauslastung etc. zu finden sein)
- Bericht (`RunReportWindow`): Zur Darstellung des Berichtes bei Beendigung einer Projektausführung.
- Einstellungen (`SettingsWindow`): Zur Darstellung und Bearbeitung von Einstellungen.
- Erweiterte Einstellungen (`AdvancedSettingsWindow`): Zur Darstellung und Bearbeitung von erweiterten Einstellungen. (grösstenteils nicht für den normalen Nutzer relevant)
- Element Auswahl (`NodeCollectionWindow`): Zur Auswahl und dem Platzieren von neuen Elementen.
- Projekt (`ProjectWindow`): Zur Darstellung von projektspezifischen Informationen. (Später sollen hier auch projektspezifische Einstellungen zu finden sein)
- Text Zeigen (`ShowTextWindow`): Zur Darstellung von Text. (Während der Projektausführung)
- Bild Zeigen (`ShowBitmapWindow`): Zur Darstellung von Bildern. (Während der Projektausführung)
- Mathematisches Objekt Zeigen (`ShowMathObjectWindow`) Zur Darstellung von Mathematischen Objekten. (Während der Projektausführung)
- Histogram Zeigen (`ShowNumberArrayWindow`): Zur Darstellung von Werte-Listen. (Während der Projektausführung)

Die Fenster setzen teils mehr teils weniger auf Standardkomponenten. Viele grafische Komponenten stammen nicht aus dem Standard oder einem fremden Framework sondern wurden eigens für das Programm implementiert.

##### Dialoge

Auch wenn eine Reihe von Dialogen bereits durch das Java-Swing-Framework (`javax.swing.*`) vorgegeben werden und damit nicht selbst implementiert werden müssen decken diese jeweils nur sehr spezielle Fälle ab (Eingabe von Text, Datei-Öffnen-Dialog, Farbauswahl-Dialog, etc.).
Aus diesem Grund war es nötig für bestimmte Aufgaben eigene Dialoge zu entwickeln. Folgende Dialoge wurden eigenständig entwickelt:

- Java-Code-Eingabe-Dialog (`CodeInputDialog`): Aufgabe dieses Dialoges ist es dem Benutzer die Möglichkeit zu geben neuen **Java-Code** einzugeben Bzw. bestehenden Java-Code zu editieren, zu kompilieren und zu testen.
- Vektor-Eingabe-Dialog (`VectorInputDialog`): Aufgabe dieses Dialoges ist es dem Benutzer die Möglichkeit zu geben neue **Vektoren** zu erstellen Bzw. bestehende Vektoren zu editieren.
- Vektor-Eingabe-Dialog (`VectorInputDialog`): Aufgabe dieses Dialoges ist es dem Benutzer die Möglichkeit zu geben neue **Matrizen** zu erstellen Bzw. bestehende Matrizen zu editieren.

#### Hauptfenster



das hauptfesnter setzt ich aus folgenden kompokm mfsnmsdf



![](Grafiken/Technische-Umsetzung/Drafter-Hauptfenster.pdf)

##### ShowStates

![](Grafiken/Technische-Umsetzung/ShowStates.pdf)


Das Hauptfenster befindet sich zu jedem Zeitpunkt in einem `ShowState`. Ein `ShowState`



#### Entwickelte Komponenten

Auch wenn verschiedene der hier vorgestellten Komponenten nur in einem Fenster/Dialog verwendet werden so lag der Fokus bei diesen darauf diese Komponenten allgemein zu entwickeln so dass diese einfach für andere Applikationen wiederverwendet werden können.

##### InputKonzept

Damit eigene Komponenten welche nicht von der Swing-Klasse `JPanel` auf Benutzereingabe reagieren können habe ich eine eigene Klasse `InputManager` entwickelt. An dieser können sich Komponenten anmelden welche das eigene Interface `MouseAndKeyboardListener` unterstützen. Dieses Interface ermöglicht es der Klasse `InputManager` zu entscheiden welche Benutzereingaben welcher Komponente zuzuordnen sind. Klickt der Benutzer innerhalb eines Fensters auf eine Stelle oder gibt in einem Fenster welches gerade fokussiert ist einen Symbol ein so wird diese Eingabe über ein an diesem Fenster angemeldeten `ActionListener` an den `InputManager` übergeben und an die entsprechende an diesem angemeldete Komponente übergeben.

##### Ladebalken

![](Grafiken/Technische-Umsetzung/Ladebalken.png)

Wird das Programm gestartet wird der Benutzer mit einem Ladebalken begrüsst. Auch wenn Ladebalken eher unbeliebt sind so erfüllen diese doch den Zweck dem Benutzer eine Rückmeldung darüber zu geben dass das Programm gestartet ist und zeitnah bereit steht und genutzt werden kann. Auch wenn die Implementierung eines Ladebalken nicht den Anschein hat technisch komplex zu sein so gab es trotzdem einige Aspekte bei der Umsetzung von diesem zu beachten.

Ziel eines Ladebalken ist dem Benutzer möglich schnell eine Rückmeldung über das aktuelle Programm zu geben. Aus diesem Grund war es mir wichtig die Zeit zwischen Start der Applikation und Anzeige dieses Ladebalkens zu optimieren. Hierbei ist es interessant dass die Tatsache auf dem Lade-Screen keine Schriften angezeigt werden kein Zufall ist sondern damit zu tun hat dass das Laden von Schriften unter Java rund 1-3 Sekunden in Anspruch nehmen kann. Sämtliche mit Java umgesetzte Programme welche auf dem ersten Screen bereits Text anzeigen starten aus diesem Grund verzögert. Um diesen Effekt zu vermeiden habe ich beim Lade-Screen auf die Darstellung von Text verzichtet und lade diese im Hintergrund (indem ich diese in einen Offscreen-Bereich zeichne).

Da der Ladebalken nicht auf Benutzereingaben regieren muss und den Programmstart möglichst nicht verzögern soll steht der Code welche für das Zeichnen dieses Balkens zuständig ist fest programmiert im Programmcode der Zeichenmethode des Hauptpanels.

##### Toolbar

![](Grafiken/Technische-Umsetzung/Toolbar-Storyboard.pdf)

Obwohl die Toolbar als allgemeine Komponente entwickelt wurde wird sie nur im Hauptfenster verwendet und ist dort eine der wichtigsten Komponenten. Die Toolbar wird durch die gleichnamige Klasse `Toolbar` beschrieben und durch die Klasse `ToobarDrafter` gezeichnet. Die Toolbar hat keine Position da sie automatisch davon ausgeht sich im oberen Bereich der View zu befinden. Sie implementiert das Interface `MouseAndKeyboardListener` und kann damit an einem `InputManager` angemeldet werden. Die Toolbar enthält Instanzen der abstrakten Klasse `ToolbarItem`. Diese setzt sich zusammen aus einem Namen, einem Bild und 2 abstrakten Methoden welche zur Laufzeit entscheiden ob der Eintrag sichtbar ist und was bei einem Klick passieren soll.

##### Scrollbar

![](Grafiken/Technische-Umsetzung/Scrollbar.png)

Diese Komponente wird an 2 Stellen verwendet:

- Im Hauptfenster (vertikal und horizontal)
- In der allgemeinen Komponente Konsolen-Panel (nur vertikal)

Eine Scrollbar wird durch die gleichnamige Klasse `Scrollbar` beschrieben und durch die Klasse `ScrollbarDrafter` gezeichnet. Eine Scrollbar besteht aus einer Scroll-Richtung (vertikal oder horizontal), einer Fläche (`Area`), einer Position (zwischen 0 und 1), und einer repräsentierten Höhe/Breite. Die Komponente implementiert das Interface `MouseAndKeyboardListener` lässt sich an einem `InputManager` anmelden. Ein allgemeines Problem bei der Swing-Scrollbar ist es dass schlecht kontrollierbareEffekte auftreten wenn sich die Grösse der Fläche auf welche sie sich bezieht ändert. Sinn dieser eigenen Komponente ist es dass sich die repräsentierte Fläche dynamisch ändern kann ohne das die Position springt oder sonstige nicht benutzerfreundliche Effekte auftreten. Auch wurde bei der Implementierung der Scrollbar darauf wert gelegt dass das zwischen Bar und Rahmen das gleiche Verhältnis besteht wie zwischen repräsentierter Höhe/Breite und Komponenten Höhe/Breite.
Die Höhe/Breite der Scrollbar entspricht also immer $\frac{ (Scrollbar\ Größe)^{ 2 } }{ (Repräsentierte\ Größe) }$.

##### Konsolen-Panel

Diese Komponente ist nicht wie die anderen Komponenten fsdfsdf


### Persistente Einstellungen

### Protokollierung

### Über Reflexion geladene Klassen und geteilte Klassen/Schnittstellen

### Weitere Konzepte

SmartIdentifier





### Entstandener Umfang an Codezeilen

[*CLOC*](http://cloc.sourceforge.net/) Ausgabe:

```
$ cloc ~/GitHub/Bachelor-Projekt/Quellcode\ Hauptprogramm/src

     522 text files.
     522 unique files.                                          
      14 files ignored.

github.com/AlDanial/cloc v 1.72  T=2.60 s (195.3 files/s, 20961.3 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Java                           508           8484           2101          43946
-------------------------------------------------------------------------------
SUM:                           508           8484           2101          43946
-------------------------------------------------------------------------------
```

Das reine Hauptprogramm umfasst 508 Java-Dateien organisiert in 113 Paketen. Summiert sind in diesen 43946 Zeilen Java-Code enthalten (leere Zeilen und Kommentare ausgeschlossen). Es sind keine fremden Dateien mit Ausnahme der Datei Gauss.java welche ich (mit Erlaubnis) aus den Unterlagen der Vorlesung *Computergrafik* von Prof. Dr. F.N. Rudolph entnommen habe.



### Implementierungsdetails einzelne Module
### Verwendete Bibliotheken
## Verwendete und erstellte Grafiken
## Hilfstool *Templategenerator*

